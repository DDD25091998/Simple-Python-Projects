# -*- coding: utf-8 -*-
"""Simple Projects.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-hCJ0x0Bh26juUcGrMoZM8ivmNtFaq14

#Simple basic projects in Python 

**Must run on Google collab **


I give this small list of Algorithms to show I have a knowledge of Python syntax and logic. I have a dded a completed more complex task with neural networks to prove I understand more advanced tasks.

**An iterative Peak-finding algorithm**
"""

#Slow iterative algorithm
def peak_finder(lists):
  
#Check if the list is long enough
  
  if len(input_a) > 2:
    

#Is the first one the peak ?
    if lists[0]>lists[1]:
      print("bravo the answer is the first element")
      print (0)
      
#Is it the last one ? 
    if lists[-1]>lists[-2]:
      print("last one ")
      print (len(lists))
      
#Iterate through the entire list  
    for i in range(1,len(lists)-1):
      if lists[i]>lists[i-1] and lists[i]>lists[i+1]:
        print("it took a few tries, here is your answer, element n°")
        print (i)
  
      
  else :
    print("not long enough list")    

#Inputs
input_a = [1,2,3,4,5,0]
input_b = [10,4,3,2,1]
input_c = [1,2,3,4,5,100]


peak_finder(input_a)
peak_finder(input_b)
peak_finder(input_c)

"""**A reccurrent Peak-finding algorithm**"""

def splitter_f(lists):
  middle = len(lists)//2
  

  
  if middle>0 and lists[middle]>lists[middle+1] and lists[middle]>lists[middle-1]:
    
    return lists[middle]
  elif lists[middle]>=lists[middle+1] and lists[middle]<=lists[middle-1]:
    #go right
    return splitter_f(lists[:middle])
  
  elif lists[middle]<=lists[middle+1] and lists[middle]>=lists[middle-1] : 
    #go left
    
    return splitter_f(lists[middle:])
  
  




def recursivefinder(lists):
  original_list = lists
  
  if lists[0]>lists[1]:
    return "the answer is the first element, index : ", 0
    
  elif lists[-1]>lists[-2]:
    return "the answer is the last element, index : ",len(lists)
    
  else:
    return "the answer was in the middle, index n°",lists.index(splitter_f(lists))
    
    
    


print(recursivefinder(input_a))
print(recursivefinder(input_b))
print(recursivefinder(input_c))

"""**Max profit in single-dimension stockmarket**

Description of the algorithm : 


Profit per share =  (buy price[at time t] - sell price[at any time t+1] )

Optimal profit per share = (minimum buy price[at time t] - maximum sell price[at any time s>t]   )

Algorithm :
- INPUT : takes as an input a list of prices on various days
- OUTPUT : optimal profit per share

Our algorithm needs to find the pairwise matching of the minimum and the maximum of the array so that the minimum's index is smaller than the maximum's. Then it needs to compute the difference between the two, we obviously want to maximise this difference. 

This boils down to three possibilities : 
1. The maximum difference is on the left hand side of the array 
2. The maximum difference is on the right hand side of the array 
3. The minimum buy price is on the left and the maximum sell price is on the right 


Our algorithm therefore does a three step process : 
- Step 1 : recursively divide the algorithm into two halves ( repeat until you have reached a length of one on all subarrays arrays) 
- Step 2 : Calculate the difference between the minimum share price ( buy price ), maximum share price ( sell price ) for every one of the arrays going from the shortest one up 
- Step 3 : Return the maximum difference out of all these arrays
"""

#Python Implementation 

def wolves(A):
  
  
  
  if len(A) <= 1: #Buying and selling on the same day 
    return 0
	
  #divide the problem in two sides
  left = A[:len(A)//2]
  right = A[len(A)//2:]
 
  
  #recursively splitting the right and left sides 
  left_best = wolves(left)
  right_best = wolves(right)
  
  
  
  #Case 3 : the best buying price is left and best selling price is right
  cross_best = max(right) - min(left)
  
  
  return max(left_best,right_best,cross_best)


A = [1,2,3,4,5]#cross best is best
B = [1,201,3,4,5,6,7,8] #left best is best
C = [1,2,3,4,5,6,7,801] #right best is best
D = [5,4,3,2,1]#worst case scenario : no possibilities of profit 

print( "\n",wolves(A),"\n",wolves(B),"\n",wolves(C),"\n",wolves(D))

"""**Iterative fibonnaci number generator**"""

def linear_fib(x) : 
  
  if x == 1 :
    return 1
  f1,f2 = 0,1
  for i in range(1,x):
    f1,f2 = f2,f1+f2
    
  return f2

linear_fib(10)

"""**Checking if a list is sum free ( if no sum of two elements gives one of the lists' elements )**"""

entry_list = [1,2,3,4,8,6]
def isit(entry):
  sum_list = []
  for i in range (0,len(entry)):# go through the list once 
    for j in range (i+1,len(entry)):
      x = entry[i]
      y = entry[j]
      sums = x+y
      sum_list.append(sums)
  
 
  for k in entry:
    
    
    if k in sum_list:
      
        return (False)#It is a list with sums
    
      
  return (True)#it is a sum free list


print(isit([1,2,3,4,8,6]),
isit([1,2,4,15,22]))

print(isit([-2,1,3]))